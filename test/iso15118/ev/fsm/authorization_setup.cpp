// SPDX-License-Identifier: Apache-2.0
// Copyright 2025 Pionix GmbH and Contributors to EVerest
#include <catch2/catch_test_macros.hpp>

#include "helper.hpp"

#include <iso15118/ev/d20/state/authorization_setup.hpp>
#include <iso15118/message/authorization_setup.hpp>
#include <iso15118/message/session_setup.hpp>
#include <iso15118/message/type.hpp>

using namespace iso15118;

SCENARIO("ISO15118-20 EV authorization setup state transitions") {

    auto state_helper = FsmStateHelper();
    auto ctx = state_helper.get_context();

    GIVEN("Good case - new session") {
        fsm::v2::FSM<ev::d20::StateBase> fsm{ctx.create_state<ev::d20::state::AuthorizationSetup>()};

        const auto header = message_20::Header{
            .session_id = std::array<uint8_t, 8>{0x10, 0x34, 0xAB, 0x7A, 0x01, 0xF3, 0x95, 0x02},
            .timestamp = 1691411798,
        };
        const auto res = message_20::SessionSetupResponse{
            header, message_20::datatypes::ResponseCode::OK_NewSessionEstablished, "everest se"};

        state_helper.handle_response(res);
        const auto result = fsm.feed(ev::d20::Event::V2GTP_MESSAGE);

        THEN("Check if authorization setup is sent") {
            REQUIRE(result.transitioned() == true);
            REQUIRE(fsm.get_current_state_id() == ev::d20::StateID::Authorization);

            const auto request_message = ctx.get_request<message_20::AuthorizationSetupRequest>();
            REQUIRE(request_message.has_value());

            const auto& authorization_setup_req = request_message.value();
            REQUIRE(authorization_setup_req.header.session_id == ctx.get_session().get_id());
        }
    }
    GIVEN("Good case - resume old session") {
        fsm::v2::FSM<ev::d20::StateBase> fsm{ctx.create_state<ev::d20::state::AuthorizationSetup>()};

        // Set the session ID to match the one in the SessionSetupResponse
        ctx.get_session().set_id(std::array<uint8_t, 8>{0x10, 0x34, 0xAB, 0x7A, 0x01, 0xF3, 0x95, 0x02});

        // Set a the same charger cert hash as the one that was used to create the session
        ctx.set_charger_cert_hash(io::sha512_hash_t{
            0x3F, 0x66, 0xE4, 0x5F, 0x3A, 0x30, 0x3B, 0x8F, 0x47, 0xCD, 0xD6, 0x86, 0xAD, 0x75, 0x13, 0x6F,
            0xCE, 0x44, 0xE6, 0xAD, 0xDC, 0x52, 0x8A, 0x6A, 0x3D, 0xAC, 0x5F, 0x8D, 0xCB, 0x5A, 0x67, 0xF3,
            0xE5, 0xA5, 0xF2, 0x56, 0x74, 0x5A, 0xFA, 0xF2, 0x28, 0x31, 0xCE, 0xAB, 0xE8, 0x3C, 0xD7, 0x3C,
            0xF2, 0x83, 0x81, 0xAA, 0x5D, 0x87, 0x13, 0xA5, 0x78, 0xA8, 0xB4, 0xAB, 0x0D, 0x62, 0x1F, 0x84});

        ctx.set_charger_cert_session_hash(io::sha512_hash_t{
            0x77, 0xb7, 0x7a, 0xd3, 0x3,  0xd0, 0xb1, 0xed, 0x28, 0xe8, 0x23, 0xed, 0xe4, 0xe9, 0xc3, 0xe5,
            0x85, 0xce, 0x47, 0x4d, 0xa5, 0x91, 0xa8, 0x40, 0x18, 0xdb, 0xac, 0x2c, 0xf0, 0x22, 0x30, 0x3c,
            0x51, 0x13, 0xbb, 0x5,  0x95, 0x30, 0x66, 0x11, 0x46, 0xb8, 0x94, 0x3e, 0x59, 0x6d, 0x35, 0xae,
            0x9,  0x76, 0xfa, 0x2a, 0x3b, 0xb0, 0x63, 0x6e, 0x12, 0x7f, 0x10, 0xdb, 0x60, 0xd6, 0xb7, 0x4d});

        const auto header = message_20::Header{
            .session_id = std::array<uint8_t, 8>{0x10, 0x34, 0xAB, 0x7A, 0x01, 0xF3, 0x95, 0x02},
            .timestamp = 1691411798,
        };
        const auto res = message_20::SessionSetupResponse{
            header, message_20::datatypes::ResponseCode::OK_OldSessionJoined, "everest se"};

        state_helper.handle_response(res);
        const auto result = fsm.feed(ev::d20::Event::V2GTP_MESSAGE);

        THEN("Check if DC_ChargeParameterDiscovery is sent") {
            REQUIRE(result.transitioned() == true);
            REQUIRE(fsm.get_current_state_id() == ev::d20::StateID::ScheduleExchange);

            const auto request_message = ctx.get_request<message_20::DC_ChargeParameterDiscoveryRequest>();
            REQUIRE(request_message.has_value());

            const auto& dc_charge_param_discovery_req = request_message.value();
            REQUIRE(dc_charge_param_discovery_req.header.session_id == ctx.get_session().get_id());
        }
    }

    GIVEN("Bad case - resume old session with wrong session id") {
        fsm::v2::FSM<ev::d20::StateBase> fsm{ctx.create_state<ev::d20::state::AuthorizationSetup>()};

        // Set the session ID to not match the one in the SessionSetupResponse
        ctx.get_session().set_id(std::array<uint8_t, 8>{0x10, 0x34, 0xAB, 0x7A, 0x01, 0xF3, 0x95, 0x02});

        // Set a the same charger cert hash as the one that was used to create the session
        ctx.set_charger_cert_hash(io::sha512_hash_t{
            0x3F, 0x66, 0xE4, 0x5F, 0x3A, 0x30, 0x3B, 0x8F, 0x47, 0xCD, 0xD6, 0x86, 0xAD, 0x75, 0x13, 0x6F,
            0xCE, 0x44, 0xE6, 0xAD, 0xDC, 0x52, 0x8A, 0x6A, 0x3D, 0xAC, 0x5F, 0x8D, 0xCB, 0x5A, 0x67, 0xF3,
            0xE5, 0xA5, 0xF2, 0x56, 0x74, 0x5A, 0xFA, 0xF2, 0x28, 0x31, 0xCE, 0xAB, 0xE8, 0x3C, 0xD7, 0x3C,
            0xF2, 0x83, 0x81, 0xAA, 0x5D, 0x87, 0x13, 0xA5, 0x78, 0xA8, 0xB4, 0xAB, 0x0D, 0x62, 0x1F, 0x84});

        ctx.set_charger_cert_session_hash(io::sha512_hash_t{
            0x77, 0xb7, 0x7a, 0xd3, 0x3,  0xd0, 0xb1, 0xed, 0x28, 0xe8, 0x23, 0xed, 0xe4, 0xe9, 0xc3, 0xe5,
            0x85, 0xce, 0x47, 0x4d, 0xa5, 0x91, 0xa8, 0x40, 0x18, 0xdb, 0xac, 0x2c, 0xf0, 0x22, 0x30, 0x3c,
            0x51, 0x13, 0xbb, 0x5,  0x95, 0x30, 0x66, 0x11, 0x46, 0xb8, 0x94, 0x3e, 0x59, 0x6d, 0x35, 0xae,
            0x9,  0x76, 0xfa, 0x2a, 0x3b, 0xb0, 0x63, 0x6e, 0x12, 0x7f, 0x10, 0xdb, 0x60, 0xd6, 0xb7, 0x4d});

        const auto header = message_20::Header{
            .session_id = std::array<uint8_t, 8>{0x10, 0x34, 0xAB, 0x7A, 0x01, 0xF3, 0x95, 0x03},
            .timestamp = 1691411798,
        };
        const auto res = message_20::SessionSetupResponse{
            header, message_20::datatypes::ResponseCode::OK_OldSessionJoined, "everest se"};

        state_helper.handle_response(res);
        const auto result = fsm.feed(ev::d20::Event::V2GTP_MESSAGE);

        THEN("Check if session is stopped.") {
            REQUIRE(result.transitioned() == false);
            REQUIRE(result.FeedResult::operator bool() == false);
            REQUIRE(ctx.is_session_stopped() == true);
        }
    }

    GIVEN("Bad case - resume old session with wrong charger cert hash") {
        fsm::v2::FSM<ev::d20::StateBase> fsm{ctx.create_state<ev::d20::state::AuthorizationSetup>()};

        // Set the session ID to match the one in the SessionSetupResponse
        ctx.get_session().set_id(std::array<uint8_t, 8>{0x10, 0x34, 0xAB, 0x7A, 0x01, 0xF3, 0x95, 0x02});

        const auto header = message_20::Header{
            .session_id = std::array<uint8_t, 8>{0x10, 0x34, 0xAB, 0x7A, 0x01, 0xF3, 0x95, 0x02},
            .timestamp = 1691411798,
        };

        // Set a different charger cert hash than the one that was used to create the session
        ctx.set_charger_cert_hash(io::sha512_hash_t{
            0x3F, 0x66, 0xE4, 0x5F, 0x3A, 0x30, 0x3B, 0x8F, 0x47, 0xCD, 0xD6, 0x86, 0xAD, 0x75, 0x13, 0x6F,
            0xCE, 0x44, 0xE6, 0xAD, 0xDC, 0x52, 0x8A, 0x6A, 0x3D, 0xAC, 0x5F, 0x8D, 0xCB, 0x5A, 0x67, 0xF3,
            0xE5, 0xA5, 0xF2, 0x56, 0x74, 0x5A, 0xFA, 0xF2, 0x28, 0x31, 0xCE, 0xAB, 0xE8, 0x3C, 0xD7, 0x3C,
            0xF2, 0x83, 0x81, 0xAA, 0x5D, 0x87, 0x13, 0xA5, 0x78, 0xA8, 0xB4, 0xAB, 0x0D, 0x62, 0x1F, 0x85});

        ctx.set_charger_cert_session_hash(io::sha512_hash_t{
            0x77, 0xb7, 0x7a, 0xd3, 0x3,  0xd0, 0xb1, 0xed, 0x28, 0xe8, 0x23, 0xed, 0xe4, 0xe9, 0xc3, 0xe5,
            0x85, 0xce, 0x47, 0x4d, 0xa5, 0x91, 0xa8, 0x40, 0x18, 0xdb, 0xac, 0x2c, 0xf0, 0x22, 0x30, 0x3c,
            0x51, 0x13, 0xbb, 0x5,  0x95, 0x30, 0x66, 0x11, 0x46, 0xb8, 0x94, 0x3e, 0x59, 0x6d, 0x35, 0xae,
            0x9,  0x76, 0xfa, 0x2a, 0x3b, 0xb0, 0x63, 0x6e, 0x12, 0x7f, 0x10, 0xdb, 0x60, 0xd6, 0xb7, 0x4d});

        const auto res = message_20::SessionSetupResponse{
            header, message_20::datatypes::ResponseCode::OK_OldSessionJoined, "everest se"};

        state_helper.handle_response(res);
        const auto result = fsm.feed(ev::d20::Event::V2GTP_MESSAGE);

        THEN("Check if session is stopped.") {
            REQUIRE(result.transitioned() == false);
            REQUIRE(result.FeedResult::operator bool() == false);
            REQUIRE(ctx.is_session_stopped() == true);
        }
    }
}
